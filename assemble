#!/usr/bin/python
import sys
import logging
import argparse
import pprint
from resources import msp430_info
# Set up logging
logging.basicConfig(filename='mspasm.log')
logger = logging.getLogger('BABY ASSEMBLER')
log_cmd = logging.StreamHandler()
logger.addHandler(log_cmd)

class BabyAssembler:
    def __init__(self,args):
        self.args = args
        self.list_cols = []
        self.orgs = []
        self.orgs_i = []
        self.labels = {}

    def __convert_to_opcode(self,instruction):
        result = None
        for opcodes in msp430_info.OPCODES:
            result = opcodes.get(instruction)
            if result is None:
                continue
            else:
                return result
        # Got to here. If instruction isn't in there, maybe it's
        # because it's a .b or .w
        for opcodes in msp430_info.OPCODES:
            result = opcodes.get(instruction[:-2])
            if result is None:
                continue
            else:
                return result
        # Failed both tests. Probably not an opcode
        return result
        

    def __init_cols(self):
        self.col_0 = [None] * self.size         # Source File Line Number
        self.col_1 = [None] * self.size         # Addr
        self.col_2 = [''] * self.size           # Encoded Instruction
        self.col_3 = [''] * self.size           # Opcode
        self.col_4 = [''] * self.size           # SRC
        self.col_5 = [''] * self.size           # DST
    

    def __get_size(self,code):
        logger.debug('Getting the number of lines of code.')
        for i,line in enumerate(code):
            try:
                if line.strip().split()[0] == 'END':
                    logger.debug('Found the END directive.')
                    self.size = i
                else:
                    continue
            except IndexError:
                pass

    # First pass of the assembler
    def __first_pass(self,code):
        last_was_org = False
        for i,line in enumerate(code):
            line.strip()
            instruction = line.split()
            try:
                self.col_3[i] = line.strip()
                # Now check if the last address was defined
                if not (i==0):
                    logger.debug('Checking if last address was defined')
                    if last_was_org:
                        logger.debug('Last instruction was ORG directive. Setting address to {}.'.format(self.orgs[-1]))
                        self.col_1[i] = self.orgs[-1]
                        last_was_org = False
                    elif (not self.col_1[i-1] and self.orgs):
                        logger.debug('Last address was not defined, setting to whatever is in ORGs.')
                        self.col_1[i] = self.orgs[-1]
                    # If the last address was defined, set it to that for now
                    elif (self.col_1[i-1] and not self.col_1[i]):
                        logger.debug('Last address is defined. Setting current address to that for now.')
                        self.col_1[i] = self.col_1[i-1]

                    
                # First find the assembler directive ORG
                if instruction[0] == 'ORG':
                    last_was_org = True
                    # Address will be in the next element in the list
                    self.col_1[i] = instruction[1]
                    logger.debug('Found ORG directive, line {}, address {}'.format(i,self.col_1[i]))
                    # Go ahead and store the line number while we're
                    # here
                    self.col_0[i] = i

                    # There's no other fields that should be filled
                    # right of this for assembler directives, so fill
                    # with whitespace
                    self.col_2[i] = ''
                    self.col_4[i] = ''
                    self.col_5[i] = ''
                    # Store the last place the ORG was defined
                    self.orgs_i.append(i)
                    self.orgs.append(self.col_1[i])
                    continue
                    
                elif not self.__convert_to_opcode(instruction[0]) is None:
                    logger.debug('Recognized an opcode ({}). Not encoding it for the first pass.'.format(instruction[0]))
                    # Now to determine if this was emulated or not
                    tmp = self.__convert_to_opcode(instruction[0])
                    offset = 0
                    self.col_1[i+1] = hex(int(str(self.col_1[i]),0)+2)
                    # logger.critical('Immediately added 2 before processing further.')
                    # logger.critical('Next address is: {}'.format(self.col_1[i+1]))
                    if isinstance(tmp,list):
                        # logger.critical('{} is an emulated instruction: {}'.format(instruction[0],tmp))
                        # This is an emulated instruction
                        offset = int(tmp[0])
                        
                    # Now to determine how much we need to increment the address counter by
                    if '#0x' in instruction:
                        self.col_1[i+1] = hex(int(str(self.col_1[i+1]),0)+2)
                    if '&' in instruction:
                        self.col_1[i+1] = hex(int(str(self.col_1[i+1]),0)+2)
                        
                    self.col_1[i+1] = hex(int(str(self.col_1[i+1]),0)+offset)
                    self.col_1[i+1] = '0x'+str(self.col_1[i+1])[2:].zfill(4)
                    continue
                
                elif instruction[0][0] == ';':
                    logger.debug('Found comment at line {}'.format(i))
                    if not(i==0):
                        if self.col_1[i] is None:
                            logger.warning('Previous address was None')
                            continue
                        else:
                            self.col_1[i+1] = self.col_1[i]
                            continue
                    else:
                        if not(i==(len(code)-1)):
                            logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i]),i)
                            self.col_1[i+1] = self.col_1[i]
                            continue
                        else:
                            logger.debug('No found previous value. Continuing.')
                            continue
                    
                # If the first part of the instruction did not match any of these then
                # it must be a label
                else:
                    logger.debug('No other matches so far for instruction {}'.format(instruction[0]))
                    if not (i==0):
                        if self.labels.get(instruction[0]) is None:
                            logger.debug('Found new label: {} (line {})'.format(instruction[0],i))
                            self.labels[instruction[0]] = self.col_1[i]
                            self.col_1[i+1] = self.col_1[i]
                            was_label = True
                        else:
                            if self.labels.get(instruction[0]) == self.col_1[i]:
                                pass
                            else:
                                logger.debug('Found duplicate label {} (line {})'.format(instruction[0],i))
                                dupkey = 'err'+instruction[0]
                                self.labels[dupkey] = self.col_1[i]
                                was_label = True
                    else:
                        # Must be a label?
                        logger.debug('I guess this is a label?')
                        if self.labels.get(instruction[0]) is None:
                            self.labels[instruction[0]] = self.col_1[0]
                            was_label = True
                        else:
                            dupkey = 'err'+instruction[0]
                            self.labels[dupkey] = self.col_1[0]
                            was_label = True
                        continue

                if not (self.__convert_to_opcode(instruction[1]) is None):
                    self.col_1[i+1] = hex(int(str(self.col_1[i]),0)+2)
                    self.col_1[i+1] = '0x'+str(self.col_1[i+1])[2:].zfill(4)

                elif instruction[1] == 'EQU':
                    if self.col_1[i] is None:
                        continue
                    else:
                        logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i],i))
                        self.col_1[i+1] = self.col_1[i]
                        continue
                # Next try to find constants in RAM
                elif instruction[1] == 'DW':
                    # self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i+1] = hex(int(self.col_1[i],0)+2)
                    self.col_1[i+1] = '0x'+str(self.col_1[i+1])[2:].zfill(4)

                elif instruction[1] == 'DS':
                    # self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i+1] = hex(int(self.col_1[i],0)+int(instruction[2]))
                    self.col_1[i+1] = '0x'+str(self.col_1[i+1])[2:].zfill(4)

                # Next try to find constants in RAM
                elif instruction[1] == 'DB':
                    # self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i+1] = hex(int(self.col_1[i],0)+1)
                    self.col_1[i+1] = '0x'+str(self.col_1[i+1])[2:].zfill(4)

                else:
                    if not(i==0):
                        if self.col_1[i-1] is None:
                            logger.warning('Got to the else, previous address was None.')
                            continue
                        else:
                            logger.debug('No match found for {}, assuming it\'s just whitespace.'.format(instruction))
                            self.col_1[i+1] = self.col_1[i]
                            
                    else:
                        logger.debug('Must be whitespace on the first line.')
                        logger.debug('No match found for instruction {} (line {})'.format(instruction[0],i))
                        logger.debug('Storing previous val of {} into old val {}'.format(self.col_1[i-1],self.col_1[i]))
                        self.col_1[i+1] = self.col_1[i]
                        continue
                was_label=False
                    
                
                    
            except IndexError as err:
                logger.debug('Ignoring this error: %s' % err)
                pass

        logger.info(pprint.pformat(self.labels))

    # def __second_pass(self,code):
    #     was_label = False
    #     for i,line in enumerate(code):
    #         line = line.replace(':','')
    #         instruction = line.split()


    def parse_asm(self):
        try:
            with open(self.args.asm) as asm:
                code = asm.readlines()
                self.__get_size(code)
                logger.info('Determined there are {} lines of code'.format(self.size))
                self.__init_cols()
                self.__first_pass(code)
                # self.__second_pass(code)
                
        except FileNotFoundError:
            logger.critical('Could not open file %s' % self.args.asm)
            exit()

    def write_list(self):
        f_lines = ''
        symb_tab = '%-50s %-50s\n' %('Label','Value')
        err_labels = {}
        symb_err = '{:^55}\n'.format('ERRORS:')
        symb_err += '%-50s %-50s\n' %('Duplicate Label','Value')
        for i in range(self.size):
            try:
            # Write out the LIST file
                addr = self.col_1[i][2:].upper()
                # logger.info('Address is %s' % addr)
                f_lines += '%-10s %-10s %-10s %-30s\n' % (i,addr,self.col_2[i],self.col_3[i])
            except TypeError:
                logger.warning('Column contains NoneType')
                continue
            
        for label,addr in sorted(self.labels.items()):
            try:
                if not label.startswith('err'):
                    pretty_addr = addr[2:].upper()
                    symb_tab += '%-50s %-50s\n' % (label,pretty_addr)
                else:
                    logger.debug('Found duplicate {}'.format(label[3:]))
                    err_labels[label] = addr[2:].upper()
                    # logger.debug(err_labels[label])
                    continue
                if err_labels:
                    for err,val in sorted(err_labels.items()):                                    
                        label = err[3:]
                        addr = val[2:].upper()
                        symb_err += '%-50s %-50s\n' % (label,addr)
                else:
                    pass
            except TypeError as err:
                logger.warning('Received this error when writing the symbol table: {}'.format(err))
                pass


        if self.args.list_file is None:
            try:
                fname = self.args.asm[:-4]+'.list'
                with open(fname,'w+') as f:
                    lines = f_lines+'\n\n\n\n'+symb_tab
                    if err_labels:
                        lines += '\n\n'+symb_err
                    f.writelines(lines)
                logger.debug('Wrote to file')
            except FileNotFoundError:
                logger.critical('Could not open list file')
        else:
            try:
                with open(self.args.list_file,'w+') as f:
                    lines = f_lines+'\n\n\n\n'+symb_tab
                    if err_labels:
                        lines += '\n\n'+symb_err
                    f.writelines(lines)
            except FileNotFoundError:
                logger.critical('Path to list does not exist')

parser = argparse.ArgumentParser(description='Baby assembler that produces LIST file for a subset of the MSP430 instructions')
parser.add_argument('asm',help='assembly file for the assembler to parse',metavar='asm_file')
parser.add_argument('--list_file',help='list file')
parser.add_argument('-v','--verbose',help='outputs logging to console',nargs='?',default='WARNING',metavar='LOG LEVEL',choices=['DEBUG','debug','INFO','info','WARNING','warning','ERROR','error','CRITICAL','critical'])
parser.add_argument('-m','--mem',help='write mem file for Verilog',action='store_true')
args = parser.parse_args()

try:
    if args.verbose.lower() == 'debug':
        logger.setLevel(logging.DEBUG)
    elif args.verbose.lower() == 'info':
        logger.setLevel(logging.INFO)
    elif args.verbose.lower() == 'warning':
        logger.setLevel(logging.WARNING)
    elif args.verbose.lower() == 'error':
        logger.setLevel(logging.ERROR)
    elif args.verbose.lower() == 'critical':
        logger.setLevel(logging.CRITICAL)
    else:
        logger.setLevel(logging.NOTSET)
except AttributeError:
    logger.setLevel(logging.WARNING)

# set a format which is simpler for console use
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
# tell the handler to use this format
log_cmd.setFormatter(formatter)
logger.debug('Set log level for console.')
    

mspasm = BabyAssembler(args)
mspasm.parse_asm()
mspasm.write_list()
