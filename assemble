#!/usr/bin/python
import sys
import logging
import argparse
import pprint
import pdb
# Set up logging
logging.basicConfig(filename='mspasm.log')
logger = logging.getLogger('BABY ASSEMBLER')
log_cmd = logging.StreamHandler()
logger.addHandler(log_cmd)

# Global Constants
MAX_LINES = 16383               # FFFF - C000
class Error(Exception):
    pass

class InvalidOpcodeError(Error):
    def __init__(self,msg):
        self.msg=msg
        logger.error(msg)

class BabyAssembler:
    def __init__(self,args):
        self.args = args
        self.list_cols = []
        self.orgs = []
        self.orgs_i = []
        self.labels = {}
        self.opcodes_1 = {
            'mov'    : '0100',
            'add'    : '0101',
            'addc'   : '0110',
            'subc'   : '0111',
            'sub'    : '1000',
            'cmp'    : '1001',
            'dadd'   : '1010',
            'bit'    : '1011',
            'bic'    : '1100',
            'bis'    : '1101',
            'xor'    : '1110',
            'and'    : '1111'
        }
        
        self.opcodes_2 = {
            'rrc'    : '0001' + '0000' + '0000',
            'rrc.b'  : '0001' + '0000' + '0000',
            'swpb'   : '0001' + '0000' + '1000',  
            'rra'    : '0001' + '0001' + '0000', 
            'rra.b'  : '0001' + '0001' + '0100', 
            'sxt'    : '0001' + '0001' + '1000', 
            'push'   : '0001' + '0010' + '0000',
            'push.b' : '0001' + '0010' + '0100',
            'call'   : '0001' + '0010' + '1000',
            'reti'   : '0001' + '0011' + '0000'
        }
            
            
        self.opcodes_3 = {
            'jne'    : '00100000',
            'jnz'    : '00100000',
            'jeq'    : '00100100',
            'jz'     : '00100100',
            'jnc'    : '00101000',
            'jc'     : '00101100',
            'jn'     : '00110000',
            'jge'    : '00110100',
            'jl'     : '00111000',
            'jmp'    : '00111100'
        }

        self.opcodes_all = [self.opcodes_1, self.opcodes_2, self.opcodes_3]


    def __convert_to_opcode(self,instruction):
        result = None
        for opcodes in self.opcodes_all:
            result = opcodes.get(instruction)
            if result is None:
                continue
            else:
                return result
        # Got to here. If instruction isn't in there, maybe it's
        # because it's a .b or .w
        for opcodes in self.opcodes_all:
            result = opcodes.get(instruction[:-2])
            if result is None:
                continue
            else:
                return result
        # Failed both tests. Probably not an opcode
        return result
        

    def __init_cols(self):
        self.col_0 = [None] * self.size         # Source File Line Number
        self.col_1 = [None] * self.size         # Addr
        self.col_2 = [''] * self.size         # Encoded Instruction
        self.col_3 = [''] * self.size         # Opcode
        self.col_4 = [''] * self.size         # SRC
        self.col_5 = [''] * self.size         # DST
    

    def __get_size(self,code):
        logger.debug('Getting the number of lines of code.')
        for i,line in enumerate(code):
            # logger.debug('Looking for the END directive...')
            try:
                # logger.info(line.strip().split()[0])
                if line.strip().split()[0] == 'END':
                    logger.debug('Found the END directive.')
                    self.size = i
                    # return self.size
                else:
                    continue
            except IndexError:
                pass

    # First pass of the assembler
    def __first_pass(self,code):
        for i,line in enumerate(code):
            line.strip()
            instruction = line.split()
            try:
                self.col_3[i] = line.strip()
                # First find the assembler directive ORG
                if instruction[0] == 'ORG':
                    # Address will be in the next element in the list
                    self.col_1[i] = instruction[1]
                    logger.debug('Found ORG directive, line {}, address {}'.format(i,self.col_1[i]))
                    # Go ahead and store the line number while we're
                    # here
                    self.col_0[i] = i

                    # There's no other fields that should be filled
                    # right of this for assembler directives, so fill
                    # with whitespace
                    self.col_2[i] = ''
                    # self.col_3[i] = line.strip()
                    self.col_4[i] = ''
                    self.col_5[i] = ''
                    # Store the last place the ORG was defined
                    # last_org_i = i
                    self.orgs_i.append(i)
                    self.orgs.append(self.col_1[i])
                    
            except IndexError:
                pass

        for j in range(self.orgs_i[0]):
            self.col_1[j] = self.orgs[0]

        x=0
        try:
            for x in range(len(self.orgs_i)):
                for k in range(self.orgs_i[x], self.orgs_i[x+1]):
                    self.col_1[k] = self.orgs[x]
                x+=1
                # print(x)
        except IndexError:
            pass

    def __second_pass(self,code):
        was_label = False
        for i,line in enumerate(code):
            line = line.replace(':','')
            instruction = line.split()
            try:
                line = line.strip()
                # First things first. Is this an ORG, blank line, or opcode?
                if not instruction:
                    logger.debug('Found whitespace at line {}'.format(i))
                    if not(i==0):
                        if self.col_1[i-1] is None:
                            logger.warning('Previous address was None')
                            continue
                        else:
                            logger.debug('Extending the address counter {} on this line {}'.format(self.col_1[i-1],i))
                            self.col_1[i] = self.col_1[i-1]
                            continue
                    else:
                        # if not(i==0):
                        #     logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i]),i)
                        #     self.col_1[i] = self.col_1[i-1]
                        #     continue
                        # else:
                        logger.debug('No found previous value. Continuing.')
                        continue
                    
                elif instruction[0] == 'ORG':
                    continue

                elif instruction[0] == 'END':
                    break

                elif not self.__convert_to_opcode(instruction[0]) is None:
                    self.col_1[i] = hex(int(str(self.col_1[i-1]),0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)
                
                elif instruction[0][0] == ';':
                    logger.debug('Found comment at line {}'.format(i))
                    if not(i==0):
                        if self.col_1[i-1] is None:
                            logger.warning('Previous address was None')
                            continue
                        else:
                            self.col_1[i] = self.col_1[i-1]
                            continue
                    else:
                        if not(i==0):
                            logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i]),i)
                            self.col_1[i] = self.col_1[i-1]
                            continue
                        else:
                            logger.debug('No found previous value. Continuing.')
                            continue
                    
                # If the first part of the instruction did not match any of these then
                # it must be a label
                else:
                    logger.debug('No other matches so far for instruction {}'.format(instruction[0]))
                    if not (i==0):
                        if self.labels.get(instruction[0]) is None:
                            logger.debug('Found new label: {} (line {})'.format(instruction[0],i))
                            self.labels[instruction[0]] = self.col_1[i-1]
                            self.col_1[i] = self.col_1[i-1]
                            was_label = True
                        else:
                            if self.labels.get(instruction[0]) == self.col_1[i-1]:
                                pass
                            else:
                                logger.debug('Found duplicate label {} (line {})'.format(instruction[0],i))
                                dupkey = 'err'+instruction[0]
                                self.labels[dupkey] = self.col_1[i-1]
                                was_label = True
                        # continue
                    else:
                        # Must be a label?
                        logger.debug('I guess this is a label?')
                        if self.labels.get(instruction[0]) is None:
                            self.labels[instruction[0]] = self.col_1[0]
                            was_label = True
                        else:
                            dupkey = 'err'+instruction[0]
                            self.labels[dupkey] = self.col_1[0]
                            was_label = True
                        # self.labels[instruction[0]] = self.col_1[0]
                        continue

                if not (self.__convert_to_opcode(instruction[1]) is None):
                    self.col_1[i] = hex(int(str(self.col_1[i-1]),0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                elif instruction[1] == 'EQU':
                    if self.col_1[i-1] is None:
                        continue
                    else:
                        logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i],i))
                        self.col_1[i] = self.col_1[i-1]
                        continue
                # Next try to find constants in RAM
                elif instruction[1] == 'DW':
                    # if not (i==0):
                    #     if self.labels.get(instruction[0]) is None:
                    #         self.labels[instruction[0]] = self.col_1[i-1]
                    #         was_label = True
                    #     else:
                    #         if self.labels.get(instruction[0]) == self.col_1[i-1]:
                    #             pass
                    #         else:
                    #             logger.debug('Found duplicate label {} (line {})'.format(instruction[0],i))
                    #             dupkey = 'err'+instruction[0]
                    #             self.labels[dupkey] = self.col_1[i-1]
                    #             was_label = True
                    self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i] = hex(int(self.col_1[i-1],0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                elif instruction[1] == 'DS':
                    # self.labels[instruction[0]] = self.col_1[i-1]
                    # if not (i==0):
                    #     if self.labels.get(instruction[0]) is None:
                    #         self.labels[instruction[0]] = self.col_1[i-1]
                    #         was_label = True
                    #     else:
                    #         if self.labels.get(instruction[0]) == self.col_1[i-1]:
                    #             pass
                    #         else:
                    #             logger.debug('Found duplicate label {} (line {})'.format(instruction[0],i))
                    #             dupkey = 'err'+instruction[0]
                    #             self.labels[dupkey] = self.col_1[i-1]
                    #             was_label = True
                    #         # dupkey = 'err'+instruction[0]
                    #         # self.labels[dupkey] = self.col_1[i-1]
                    #         # was_label = True
                    self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i] = hex(int(self.col_1[i-1],0)+int(instruction[2]))
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                # Next try to find constants in RAM
                elif instruction[1] == 'DB':
                    # # logger.info('Last known address was {}'.format(last_org))
                    # # self.labels[instruction[0]] = self.col_1[i-1]
                    # if not (i==0):
                    #     if self.labels.get(instruction[0]) is None:
                    #         self.labels[instruction[0]] = self.col_1[i-1]
                    #         was_label = True
                    #     else:
                    #         if self.labels.get(instruction[0]) == self.col_1[i-1]:
                    #             pass
                    #         else:
                    #             logger.debug('Found duplicate label {} (line {})'.format(instruction[0],i))
                    #             dupkey = 'err'+instruction[0]
                    #             self.labels[dupkey] = self.col_1[i-1]
                    #             was_label = True
                    #         # dupkey = 'err'+instruction[0]
                    #         # self.labels[dupkey] = self.col_1[i-1]
                    #         # was_label = True
                    self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i] = hex(int(self.col_1[i-1],0)+1)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                else:
                    if not(i==0):
                        if self.col_1[i-1] is None:
                            logger.warning('Got to the else, previous address was None.')
                            continue
                        else:
                            logger.debug('No match found for {}, assuming it\'s just be whitespace.'.format(instruction))
                            self.col_1[i] = self.col_1[i-1]
                            
                    else:
                        logger.debug('Must be whitespace on the first line.')
                        logger.debug('No match found for instruction {} (line {})'.format(instruction[0],i))
                        logger.debug('Storing previous val of {} into old val {}'.format(self.col_1[i-1],self.col_1[i]))
                        self.col_1[i] = self.col_1[i-1]
                        continue
                was_label=False

            except IndexError:
                if not instruction:
                    pass
                elif was_label:
                    pass
                else:
                    logger.critical('Could not parse through instruction: "%s" at line %s' % (instruction,i))
                    exit()
                # if i==30:
                #     print('here')
                #     exit()
                # pass

            except ValueError:
                pass

        logger.info('Labels:\n{}'.format(pprint.pformat(self.labels)))


    def parse_asm(self):
        try:
            with open(self.args.asm) as asm:
                code = asm.readlines()
                self.__get_size(code)
                logger.info('Determined there are {} lines of code'.format(self.size))
                self.__init_cols()
                self.__first_pass(code)
                self.__second_pass(code)
                
        except FileNotFoundError:
            logger.critical('Could not open file %s' % self.args.asm)
            exit()

    def write_list(self):
        f_lines = ''
        symb_tab = '%-50s %-50s\n' %('Label','Value')
        try:
            for i in range(self.size):
                addr = self.col_1[i][2:].upper()
                f_lines += '%-10s %-10s %-10s %-30s\n' % (i,addr,self.col_2[i],self.col_3[i])
            # logger.info('Flines:\n{}'.format(pprint.pformat(f_lines)))
            for label,addr in self.labels.items():
                if not label.startswith('err'):
                    pretty_addr = addr[2:].upper()
                    symb_tab += '%-50s %-50s\n' % (label,pretty_addr)
                else:
                    pretty_label = label[3:].upper()
                    symb_tab += '%-50s %-50s\n' % ('ERROR: Duplicate Label',pretty_label)
        except TypeError:
            logger.warning('Column contains NoneType')
            pass

        if self.args.list_file is None:
            try:
                fname = self.args.asm[:-4]+'.list'
                with open(fname,'w+') as f:
                    lines = f_lines+'\n\n\n\n'+symb_tab
                    f.writelines(lines)
                logger.debug('Wrote to file')
            except FileNotFoundError:
                logger.critical('Could not open list file')
        else:
            try:
                with open(self.args.list_file,'w+') as f:
                    lines = f_lines+'\n\n\n\n'+symb_tab
                    f.writelines(lines)
            except FileNotFoundError:
                logger.critical('Path to list does not exist')

parser = argparse.ArgumentParser(description='Baby assembler that produces LIST file for a subset of the MSP430 instructions')
parser.add_argument('asm',help='assembly file for the assembler to parse',metavar='asm_file')
parser.add_argument('--list_file',help='list file')
parser.add_argument('-v','--verbose',help='outputs logging to console',nargs='?',default='WARNING',metavar='LOG LEVEL',choices=['DEBUG','debug','INFO','info','WARNING','warning','ERROR','error','CRITICAL','critical'])
parser.add_argument('-m','--mem',help='write mem file for Verilog',action='store_true')
args = parser.parse_args()

try:
    if args.verbose.lower() == 'debug':
        logger.setLevel(logging.DEBUG)
    elif args.verbose.lower() == 'info':
        logger.setLevel(logging.INFO)
    elif args.verbose.lower() == 'warning':
        logger.setLevel(logging.WARNING)
    elif args.verbose.lower() == 'error':
        logger.setLevel(logging.ERROR)
    elif args.verbose.lower() == 'critical':
        logger.setLevel(logging.CRITICAL)
    else:
        logger.setLevel(logging.NOTSET)
except AttributeError:
    logger.setLevel(logging.WARNING)

# set a format which is simpler for console use
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
# tell the handler to use this format
log_cmd.setFormatter(formatter)
logger.debug('Set log level for console.')
    

mspasm = BabyAssembler(args)
mspasm.parse_asm()
mspasm.write_list()
