#!/usr/bin/python
import sys
import logging
import argparse
import pprint
import pdb
# Set up logging
logging.basicConfig(filename='mspasm.log')
logger = logging.getLogger('BABY ASSEMBLER')
log_cmd = logging.StreamHandler()
logger.addHandler(log_cmd)

# Global Constants
MAX_LINES = 16383               # FFFF - C000
class Error(Exception):
    pass

class InvalidOpcodeError(Error):
    def __init__(self,msg):
        self.msg=msg
        logger.error(msg)

class BabyAssembler:
    def __init__(self,args):
        self.args = args
        self.list_cols = []
        self.orgs = []
        self.orgs_i = []
        self.labels = {}
        self.opcodes_1 = {
            'mov'    : '0100',
            'add'    : '0101',
            'addc'   : '0110',
            'subc'   : '0111',
            'sub'    : '1000',
            'cmp'    : '1001',
            'dadd'   : '1010',
            'bit'    : '1011',
            'bic'    : '1100',
            'bis'    : '1101',
            'xor'    : '1110',
            'and'    : '1111'
        }
        
        self.opcodes_2 = {
            'rrc'    : '0001' + '0000' + '0000',
            'rrc.b'  : '0001' + '0000' + '0000',
            'swpb'   : '0001' + '0000' + '1000',  
            'rra'    : '0001' + '0001' + '0000', 
            'rra.b'  : '0001' + '0001' + '0100', 
            'sxt'    : '0001' + '0001' + '1000', 
            'push'   : '0001' + '0010' + '0000',
            'push.b' : '0001' + '0010' + '0100',
            'call'   : '0001' + '0010' + '1000',
            'reti'   : '0001' + '0011' + '0000'
        }
            
            
        self.opcodes_3 = {
            'jne'    : '00100000',
            'jnz'    : '00100000',
            'jeq'    : '00100100',
            'jz'     : '00100100',
            'jnc'    : '00101000',
            'jc'     : '00101100',
            'jn'     : '00110000',
            'jge'    : '00110100',
            'jl'     : '00111000',
            'jmp'    : '00111100'
        }

        self.opcodes_all = [self.opcodes_1, self.opcodes_2, self.opcodes_3]


    def __convert_to_opcode(self,instruction):
        result = None
        for opcodes in self.opcodes_all:
            result = opcodes.get(instruction)
            if result is None:
                continue
            else:
                return result
        # Got to here. If instruction isn't in there, maybe it's
        # because it's a .b or .w
        for opcodes in self.opcodes_all:
            result = opcodes.get(instruction[:-2])
            if result is None:
                continue
            else:
                return result
        # Failed both tests. Probably not an opcode
        return result
        

    def __init_cols(self):
        self.col_0 = [None] * self.size         # Source File Line Number
        self.col_1 = [None] * self.size         # Addr
        self.col_2 = [''] * self.size         # Encoded Instruction
        self.col_3 = [''] * self.size         # Opcode
        self.col_4 = [''] * self.size         # SRC
        self.col_5 = [''] * self.size         # DST
    

    def __get_size(self,code):
        logger.debug('Getting the number of lines of code.')
        for i,line in enumerate(code):
            # logger.debug('Looking for the END directive...')
            try:
                # logger.info(line.strip().split()[0])
                if line.strip().split()[0] == 'END':
                    logger.debug('Found the END directive.')
                    self.size = i
                    # return self.size
                else:
                    continue
            except IndexError:
                pass

    # First pass of the assembler
    def __first_pass(self,code):
        for i,line in enumerate(code):
            line.strip()
            instruction = line.split()
            try:
                self.col_3[i] = line.strip()
                # First find the assembler directive ORG
                if instruction[0] == 'ORG':
                    # Address will be in the next element in the list
                    self.col_1[i] = instruction[1]
                    logger.debug('Found ORG directive, line {}, address {}'.format(i,self.col_1[i]))
                    # Go ahead and store the line number while we're
                    # here
                    self.col_0[i] = i

                    # There's no other fields that should be filled
                    # right of this for assembler directives, so fill
                    # with whitespace
                    self.col_2[i] = ''
                    # self.col_3[i] = line.strip()
                    self.col_4[i] = ''
                    self.col_5[i] = ''
                    # Store the last place the ORG was defined
                    # last_org_i = i
                    self.orgs_i.append(i)
                    self.orgs.append(self.col_1[i])
                    
            except IndexError:
                pass

        for j in range(self.orgs_i[0]):
            self.col_1[j] = self.orgs[0]

        x=0
        try:
            for x in range(len(self.orgs_i)):
                for k in range(self.orgs_i[x], self.orgs_i[x+1]):
                    self.col_1[k] = self.orgs[x]
                x+=1
                # print(x)
        except IndexError:
            pass

    def __second_pass(self,code):
        for i,line in enumerate(code):
            line.strip()
            instruction = line.split()
            try:
                # logger.info('Operation {} is {} in opcode bits'.format(instruction[0],self.__convert_to_opcode(instruction[0])))
                line = line.strip()
                # if i==30:
                #     print(bool(not instruction))
                #     exit()
                # logger.debug('Stripped line: {}'.format(line))

                # First things first. Is this an ORG, blank line, or opcode?
                if instruction[0] == 'ORG':
                    continue

                elif not self.__convert_to_opcode(instruction[0]) is None:
                    self.col_1[i] = hex(int(str(self.col_1[i-1]),0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)
                
                elif not instruction or instruction[0][0] == ';':
                    if not(i==0):
                        if self.col_1[i-1] is None:
                            logger.warning('Previous address was None')
                            continue
                        else:
                            self.col_1[i] = self.col_1[i-1]
                            continue
                    else:
                        if not(i==0):
                            logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i]),i)
                            self.col_1[i] = self.col_1[i-1]
                            continue
                        else:
                            logger.debug('No found previous value. Continuing.')
                            continue
                    
                # elif instruction[0][0] == ';':
                #     if not(i==0):
                #         if self.col_1[i-1] is None:
                #             continue
                #         else:
                #             logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i],i))
                #             self.col_1[i] = self.col_1[i-1]
                #             continue
                # If the first part of the instruction did not match any of these then
                # it must be a label
                else:
                    if not i==0:
                        self.labels[instruction[0]] = self.col_1[i-1]
                    else:
                        continue
                    # self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    # self.col_1[i] = hex(int(self.col_1[i-1],0)+2)
                    # self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                if not self.__convert_to_opcode(instruction[1]) is None:
                    self.col_1[i] = hex(int(str(self.col_1[i-1]),0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                elif instruction[1] == 'EQU':
                    if self.col_1[i-1] is None:
                        continue
                    else:
                        logger.debug('Storing previous val of {} into old val {} (line {})'.format(self.col_1[i-1],self.col_1[i],i))
                        self.col_1[i] = self.col_1[i-1]
                        continue
                # Next try to find constants in RAM
                elif instruction[1] == 'DW' or instruction[1] == 'DS':
                    self.labels[instruction[0]] = self.col_1[i-1]
                    self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i] = hex(int(self.col_1[i-1],0)+2)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                # Next try to find constants in RAM
                elif instruction[1] == 'DB':
                    # logger.info('Last known address was {}'.format(last_org))
                    self.labels[instruction[0]] = self.col_1[i-1]
                    self.col_1[i-1] = '0x'+str(self.col_1[i-1])[2:].zfill(4)
                    self.col_1[i] = hex(int(self.col_1[i-1],0)+1)
                    self.col_1[i] = '0x'+str(self.col_1[i])[2:].zfill(4)

                else:
                    if self.col_1[i-1] is None:
                        continue
                    else:
                        logger.debug('No match found for instruction {} (line {})'.format(instruction[0],i))
                        logger.debug('Storing previous val of {} into old val {}'.format(self.col_1[i-1],self.col_1[i]))
                        self.col_1[i] = self.col_1[i-1]
                        continue

            except IndexError:
                if not instruction:
                    pass
                else:
                    logger.critical('Could not parse through instruction: "%s" at line %s' % (instruction,i))
                    exit()
                # if i==30:
                #     print('here')
                #     exit()
                # pass

            except ValueError:
                pass

        logger.info('Labels:\n{}'.format(pprint.pformat(self.labels)))


    def parse_asm(self):
        try:
            with open(self.args.asm) as asm:
                code = asm.readlines()
                self.__get_size(code)
                logger.info('Determined there are {} lines of code'.format(self.size))
                self.__init_cols()
                self.__first_pass(code)
                self.__second_pass(code)
                
        except FileNotFoundError:
            logger.critical('Could not open file %s' % self.args.asm)
            exit()

    def write_list(self):
        f_lines = ''
        try:
            for i in range(self.size):
                f_lines += '%-10s %-10s %-10s %-30s\n' % (i,self.col_1[i][2:],self.col_2[i],self.col_3[i])
        except TypeError:
            logger.warning('Column contains NoneType')
            pass

        logger.info('Flines:\n{}'.format(pprint.pformat(f_lines)))

parser = argparse.ArgumentParser(description='Baby assembler that produces LIST file for a subset of the MSP430 instructions')
parser.add_argument('asm',help='assembly file for the assembler to parse',metavar='asm_file')
parser.add_argument('-v','--verbose',help='outputs logging to console',nargs='?',default='WARNING',metavar='LOG LEVEL',choices=['DEBUG','debug','INFO','info','WARNING','warning','ERROR','error','CRITICAL','critical'])
parser.add_argument('-m','--mem',help='write mem file for Verilog',action='store_true')
args = parser.parse_args()

try:
    if args.verbose.lower() == 'debug':
        logger.setLevel(logging.DEBUG)
    elif args.verbose.lower() == 'info':
        logger.setLevel(logging.INFO)
    elif args.verbose.lower() == 'warning':
        logger.setLevel(logging.WARNING)
    elif args.verbose.lower() == 'error':
        logger.setLevel(logging.ERROR)
    elif args.verbose.lower() == 'critical':
        logger.setLevel(logging.CRITICAL)
    else:
        logger.setLevel(logging.NOTSET)
except AttributeError:
    logger.setLevel(logging.WARNING)

# set a format which is simpler for console use
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
# tell the handler to use this format
log_cmd.setFormatter(formatter)
logger.debug('Set log level for console.')
    

mspasm = BabyAssembler(args)
mspasm.parse_asm()
mspasm.write_list()
print(mspasm.col_3[31].split()[0][0])
